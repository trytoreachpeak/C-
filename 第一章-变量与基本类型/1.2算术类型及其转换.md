---
time: “2021/11/13”
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

# 算术类型及其转换

## 一、算数类型都有哪些
&emsp;&emsp;算数类型有整型和浮点型.整型中有部分类型并不是整数,他们是字符和布尔类型;浮点型是计算机中表示小数的方法,浮点型并不是通过移动小数点的位置来实现小数的,他是通过IEEE754标准实现的,跟整型有很大的差别.

## 二、整型和浮点型介绍

### 2.1 整型有哪些?
* bool
* char
* wchar_t
* char16_t
* char32_t
* short
* **int**
* long
* long long

### 2.2 带符号类型和无符号类型  
&emsp;&emsp;除去布尔型和**扩展的字符型**之外,其他整型可以分为带符号的(signed)和无符号的(unsigned).他们的表示范围跟现实生活中小学数学中的情况是一样的.
&emsp;&emsp;字符型分为3类:char,signed char和unsigned char.(实际上只有有符号和无符号的,char表现为有符号还是无符号取决于不同的编译器).

!!! attention  signed和unsigned不只是有无符号的区别
    带符号类型底层是用补码表示的, 无符号类型没有补码,也没有原码和反码.

!!! caution  小心unsigned
    * 切勿混用有符号类型和无符号类型.
    * 保证无符号类型在赋值或者是计算之后,还必须是无符号数,否则会发生意想不到的情况.

### 2.3 关于bool类型的一些讨论
&emsp;&emsp;bool类型是在C语言中没有而在C++中独有的一种基本数据类型.
&emsp;&emsp;虽然表示true或false只需要一位,但是由于最小的内存寻址单位是字节,所以bool类型只能是1字节,没有办法更小了.
&emsp;&emsp;这让我想到了bitset对象,这个类型相当于有8个bool值,似乎可以克服这个缺点.

### 2.4 关于字符型的一些讨论
&emsp;&emsp;字符型明明是字符为什么归类于整型呢,因为字符型的背后也是整型,字符型在内存中还是以01存储的.字符型的内存中存储的不同数字代表不同的字符,但是在表达式中,他就可以表示为整型,因此可以把字符型理解为小字节的整型,但是我们不推荐在表达式中使用字符型进行运算.

### 2.4 浮点型
* float
* double
* long double(**该类型比double还大,但是具体多大取决于编译器**)
  (都遵循IEEE754标准)
  (通常使用double因为能存储空间更大且计算代价相比float是一样的,在某些机器上甚至比float还快)

## 三、类型的尺寸问题
&emsp;&emsp;在不同的操作系统和CPU上都有不同的实现,这要看编译器在这些系统上是如何实现的;当然32位系统和64位系统中某些类型是一定会不相同;具体如下:
![](https://img-blog.csdn.net/20130913163641750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5X3Fpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
上表中第一行的大写字母和数字含义如下所示：
I表示：int类型
L表示：long类型
P表示：pointer指针类型
32表示：32位系统
64表示64位系统
如：LP64表示，在64位系统下的long类型和pointer类型长度为64位。
64位Linux 使用了 LP64 标准，即：long类型和pointer类型长度为64位，其他类型的长度和32位系统下相同类型的长度相同，32位和64位下类型的长度比较见上图的蓝色部分。

## 三、类型转换
###  3.1 赋值转换规则
1. 非bool类型赋给bool类型时,初始值位0结果为false,否则为true.
2. 反过来,bool值赋给非bool值时,false为0,true为1.
3. 浮点数赋值给整数,只保留浮点数中的整数部分(***小心超出范围,一般来说浮点数的范围很大***)
4. 整数赋值给浮点数,***可能损失精度***
5. 整数和浮点数可以相互转化,不需要强制转化(***这跟JAVA不一样,编译器允许这种不安全的操作***)
6. 当赋值给无符号数一个超出范围的数时,会发生轮转现象.(取模)
7. 当复制给有符号数一个超出范围的数时,***行为为定义***(**不过一般也是轮转**)
8. 条件需要bool值,因此如果我们使用了非bool值,则会发生上述转化.
9. 当bool值用于表达式计算,同理,bool值会转化成非bool值.

***一句话:要满足被赋值对象类型的要求***

### 3.2 算术转化规则
>在C++语言中,某些类型之间有关联.如果两种类型有关联,那么当程序需要其中一个类型的运算对象时,可以用另一种关联类型的对象或值来替代.换句话说,如果两种类型可以相互转化,那么他们呢就是关联的.

***算术类型之间都是可以相互转化的***    
所有规则都遵循一个共同的要求:***尽可能地减少精度损失***
转换步骤如下(步骤不可调换)
1. **整型提升**比int尺寸小的类型转化为int类型;int容纳不下的转化为unsigned(**对于16位的c++可能存在,当前cpu都是64位的,因此不存在该转化**).
2. 整型提升后,若表达式中的对象类型仍然不相同,那么表达式中的所有对象转换成尺寸最宽的类型.
3. 若表达式中有无符号和有符号整型,那么谁的尺寸最大,往谁的类型进行转换.若一样大,则转换为无符号类型.



