---
time: “2021/11/13”
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [常量和常量表达式](#常量和常量表达式)
  - [一、常量有哪些](#一-常量有哪些)
  - [二、字面值常量](#二-字面值常量)
    - [2.1 整型字面值](#21-整型字面值)
    - [2.2 浮点型字面值](#22-浮点型字面值)
    - [2.3字符和字符串字面值](#23字符和字符串字面值)
    - [2.4转义序列字面值](#24转义序列字面值)
    - [2.5布尔字面值和指针字面值](#25布尔字面值和指针字面值)
  - [三、符号常量](#三-符号常量)
  - [四、常量表达式(const expr)](#四-常量表达式const-expr)
  - [常量是对象嘛](#常量是对象嘛)
  - [有些const会被优化成常量,但是为了保证有些const就是常量,那么有了这个说明符constexpr](#有些const会被优化成常量但是为了保证有些const就是常量那么有了这个说明符constexpr)
  - [constexpr函数可以去初始化constexpr变量](#constexpr函数可以去初始化constexpr变量)
  - [constexpr告诉编译器尽情优化](#constexpr告诉编译器尽情优化)
    - [constexpr](#constexpr)

<!-- /code_chunk_output -->

# 常量和常量表达式

## 一、常量有哪些
* 字面值常量
* 符号常量
* 枚举常量

&emsp;字面常量：指的是直接输入到程序中的值
&emsp;符号常量：指的是用名称表示的常量，就像变量一样表示，但是一旦初始化，其值就不能改变.

## 二、字面值常量
一个形如42的值被称作字面值常量(literal),这样的值一望而知.每个字面值常量都对应一种数据类型,字面值常量的**形式**和**值**决定了他的数据结构;
字面值常量也分为如下几种类型:
* 整型字面值
* 浮点型字面值
* 字符和字符串字面值
* 转移序列字面值
* 布尔字面值
* 指针字面值

### 2.1 整型字面值
1. 以0开头的整数代表八进制数,以0x或0X开头的代表十六进制数.什么都不带的是十进制数.
2. 默认情况下,十进制字面值是带符号数,八进制和十六进制字面值既可能是带符号的,也可能是无符号的.
3. 若与之关联的所有类型都放不下时,将会产生错误.(**这也是为什么字面值不能过大,否则IDE直接报错的原因**)整型字面值的最大值为long long类型的长度(或者unsigned long long),若超过该类型,则跟赋给该类型超过范围的数的情况一样,发生轮转现象(取模)
4. short类型没有对应的整型字面值,最小的整型字面值是int.
5. 可以通过后缀“主动选择“字面值类型
6. 整型字面值中若有负号,看上去字面值是一个负值,实际上字面值不会是有符号数,字面值是一个无符号数.如果字面值中有符号,他的效果是对无符号数取负号.

!!! attention 后缀并不能使得字面值进行类型转换
    通过后缀主动选择字面值类型,这只是为了编译器方便对字面值做类型检查,并不会真的对字面值进行类型转换.也就是如果一个字面值超出了所选定的类型的范围,那么只会给出warning,并不会引发错误.除非该字面值已经超过来所有类型的最大范围,那么此时会发生轮转.
    如果没有添加后缀,则编译器自动判断该字面值属于哪种类型.

### 2.2 浮点型字面值
1. 如果整数部分为0,可以省略0
2. E或e表示指数部分(这里会不会又要遵循IEEE754)
3. 默认类型为double
4. 整型字面值中的(5)(6)对浮点型字面值也成立

### 2.3字符和字符串字面值
1. 由单引号括起来的一个字符成为char型字面值,双引号扩起来的零个或多个字符则构成字符串字面值
2. ***字符串字面值实际上是由常量字符构成的数组***
3. 编译器在每个字符串的结尾处添加一个空字符(‘\0’),因此,字符串字面值的实际长度比内容多1.
4. 如果两个字符串字面值位置紧邻且仅用空格,锁紧和换行符分割,则他们还是一个字符串整体,可利用该特点分行书写.

### 2.4转义序列字面值
不介绍了根本用不到,记住哪些需要转义
* \n 换行
* \"
* \'
* \?
* \\\
* \r 回车
* char
  
### 2.5布尔字面值和指针字面值
* true和false
* nullptr
* null

## 三、符号常量
符号常量将单独一个md进行讲述

## 四、常量表达式(const expr)
表达式在编译时期就确认为是常量的表达式是常量

## 常量是对象嘛
有些是有些不是,让我们来看看对象的定义:一块能存储数据并具有某种类型的内存空间,明显来说只有字符串字面值和符号常量是对象

## 有些const会被优化成常量,但是为了保证有些const就是常量,那么有了这个说明符constexpr

## constexpr函数可以去初始化constexpr变量

## constexpr告诉编译器尽情优化

 ## 字面值类型
 constexpr并不是所有类型都可以使用的,可以使用的是字面值类型
 算术类型、引用和指针都是字面值类型.自定义类Sales_item、IO库、string类型则不属于字面值类型,也就不能呗定位constexpr.其他一些字面值类型将在p267和p736中介绍.
 尽管指针和引用都能定义成constexpr,但他们的初始值却收到严格限制.他们的初始值必须是nullptr或者0,或是存储于某个固定地址中的对象.
 函数体内定义的变量一般来说并非存放在固定地址中,因此constexpr指针不能指向这样的变量.相反的,定义于所有函数题之外的对象其地址固定不变,能用来初始化constexpr指针.
 在P185提到的静态变量,允许函数定义一类有效范围超出函数本身的变量,这类变量和定义在函数体之外的变量一样也有固定地址.因此,constexpr引用能绑定到这样的变量上,constexpr指针也能指向这样的变量.
 
!!! caution
    constexpr指针中constexpr只对指针有效,与指针所指的对象无关.constexpr会把指针定义成一个顶层const而非底层const

### constexpr
constexpr int i = 42;
constexpr cosnt int *p = &i;
p = &i;
常量指针,指向整型常量i;
这个例子说明,constexpr符不仅带有检查常量表达式的意义,还带有const意义,因为const修饰的变量如果是常量,那么在编译的时候可以被优化,然而constexpr保证了一定可以被优化的常量,所以被优化的前提是这个变量被const修饰.所以constexpr一定带有const.