指针
指针实现了对另一个对象的间接访问,跟引用不同的是,他有存储空间

## 指针在底层
指针在底层表现为一个内存空间,该空间中保存着别的类型的地址

## 要求
类型需要严格匹配
除了const和P534

## 指针值
> 指针的值(即地址)应属下列4中状态之一:
> 1.指向一个对象.
> 2.指向紧邻对象所占空间的下一个位置.(拒绝访问)
> 3.空指针,意味着指针没有指向任何对象.(拒绝访问)
> 4.无效指针,也就是上述情况之外的其他值.(任何行为都会发生错误)

## 空指针
### 0
### NULL(就是0)定义在cstdlib中,cstdlib在iostream中
### NULLPTR
!!! caution
    不能变量值为0赋值给指针,这昂不是空指针


[为什么使用nullptr而不是null](https://blog.csdn.net/haimianjie2012/article/details/90698564)

[什么是void*](https://zhuanlan.zhihu.com/p/163676489)

### 一定要初始化所有指针

## 其他指针操作
指针可以参加条件判断,非空为true,空为false(若指针为0,可能在使用时转化为各种类型,而Nullptr智慧自动转化为布尔)
指针类型可以用相等操作符和不相等操作符进行比较
如果两个指针存放的地址值相等,则它们相等,反之它们不相等.
相等的情况有三种:
1. 都为空
2. 都指向同一对抗
3. 都指向同一对象的下一个对象

注意:一个指针指向某对象,同时另一个指针指向另外对象的下一地址时,也会出现相等的情况
使用非法指针进行比较会获得不可预计的结果

void*指针(补充,void*是在c语言中作为模版的一种替代)
1.void*是一种特殊的指针,它存放了内存地址,却不知道该地址中存放的是什么类型对象
2.void*能做的事
    1.与其他指针进行比较
    2.作为函数的输入或输出(可能返回不同中类型的指针,或不考虑指针的类型)
    3.赋值给另一个void*指针
3.不能做的事情:无法直接操作void*指针所指的对象,甚至都不能对void*做delete释放内存,只有强转后才可以.(若做malloc分配内存,则void*可以用free释放,free根据指针中的地址后查表,并释放内存)
